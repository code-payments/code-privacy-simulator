/* eslint-disable */
import {
  CallOptions,
  ChannelCredentials,
  ChannelOptions,
  Client,
  ClientReadableStream,
  ClientUnaryCall,
  handleServerStreamingCall,
  handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  ServiceError,
  UntypedServiceImplementation,
} from "@grpc/grpc-js";
import _m0 from "protobufjs/minimal";
import { Signature, SolanaAccountId } from "../../common/v1/model";

export const protobufPackage = "code.messaging.v1";

export interface OpenMessageStreamRequest {
  rendezvousKey: RendezvousKey | undefined;
}

export interface OpenMessageStreamResponse {
  messages: Message[];
}

export interface AckMessagesRequest {
  rendezvousKey: RendezvousKey | undefined;
  messageIds: MessageId[];
}

export interface AckMesssagesResponse {
  result: AckMesssagesResponse_Result;
}

export enum AckMesssagesResponse_Result {
  OK = 0,
  UNRECOGNIZED = -1,
}

export function ackMesssagesResponse_ResultFromJSON(object: any): AckMesssagesResponse_Result {
  switch (object) {
    case 0:
    case "OK":
      return AckMesssagesResponse_Result.OK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AckMesssagesResponse_Result.UNRECOGNIZED;
  }
}

export function ackMesssagesResponse_ResultToJSON(object: AckMesssagesResponse_Result): string {
  switch (object) {
    case AckMesssagesResponse_Result.OK:
      return "OK";
    case AckMesssagesResponse_Result.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SendMessageRequest {
  message:
    | Message
    | undefined;
  /** The rendezvous key that the message should be routed to. */
  rendezvousKey:
    | RendezvousKey
    | undefined;
  /** The signature is of serialize(Message) using the PrivateKey of the keypair. */
  signature: Signature | undefined;
}

export interface SendMessageResponse {
  result: SendMessageResponse_Result;
  /** Set if result == OK. */
  messageId: MessageId | undefined;
}

export enum SendMessageResponse_Result {
  OK = 0,
  UNRECOGNIZED = -1,
}

export function sendMessageResponse_ResultFromJSON(object: any): SendMessageResponse_Result {
  switch (object) {
    case 0:
    case "OK":
      return SendMessageResponse_Result.OK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SendMessageResponse_Result.UNRECOGNIZED;
  }
}

export function sendMessageResponse_ResultToJSON(object: SendMessageResponse_Result): string {
  switch (object) {
    case SendMessageResponse_Result.OK:
      return "OK";
    case SendMessageResponse_Result.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * MessageId identifies a message. It is only guaranteed to be unique when
 * paired with a destination (i.e. the rendezvous public key).
 */
export interface MessageId {
  value: Buffer;
}

export interface RequestForPayment {
  /** Requestor is the Kin token account on Solana to which a payment should be sent. */
  requestorAccount: SolanaAccountId | undefined;
}

export interface Message {
  /**
   * MessageId is the Id of the message. This ID is generated by the
   * server, and will _always_ be set when receiving a message.
   *
   * Server generates the message to:
   *     1. Reserve the ability for any future ID changes
   *     2. Prevent clients attempting to collide message IDs.
   */
  id:
    | MessageId
    | undefined;
  /**
   * The signature sent from SendMessageRequest, which will be injected by server.
   * This enables clients to ensure no MITM attacks were performed to hijack contents
   * of the typed message.
   */
  sendMessageRequestSignature: Signature | undefined;
  requestForPayment: RequestForPayment | undefined;
}

export interface RendezvousKey {
  value: Buffer;
}

function createBaseOpenMessageStreamRequest(): OpenMessageStreamRequest {
  return { rendezvousKey: undefined };
}

export const OpenMessageStreamRequest = {
  encode(message: OpenMessageStreamRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rendezvousKey !== undefined) {
      RendezvousKey.encode(message.rendezvousKey, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OpenMessageStreamRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenMessageStreamRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rendezvousKey = RendezvousKey.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OpenMessageStreamRequest {
    return { rendezvousKey: isSet(object.rendezvousKey) ? RendezvousKey.fromJSON(object.rendezvousKey) : undefined };
  },

  toJSON(message: OpenMessageStreamRequest): unknown {
    const obj: any = {};
    message.rendezvousKey !== undefined &&
      (obj.rendezvousKey = message.rendezvousKey ? RendezvousKey.toJSON(message.rendezvousKey) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<OpenMessageStreamRequest>, I>>(object: I): OpenMessageStreamRequest {
    const message = createBaseOpenMessageStreamRequest();
    message.rendezvousKey = (object.rendezvousKey !== undefined && object.rendezvousKey !== null)
      ? RendezvousKey.fromPartial(object.rendezvousKey)
      : undefined;
    return message;
  },
};

function createBaseOpenMessageStreamResponse(): OpenMessageStreamResponse {
  return { messages: [] };
}

export const OpenMessageStreamResponse = {
  encode(message: OpenMessageStreamResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.messages) {
      Message.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OpenMessageStreamResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenMessageStreamResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.messages.push(Message.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OpenMessageStreamResponse {
    return { messages: Array.isArray(object?.messages) ? object.messages.map((e: any) => Message.fromJSON(e)) : [] };
  },

  toJSON(message: OpenMessageStreamResponse): unknown {
    const obj: any = {};
    if (message.messages) {
      obj.messages = message.messages.map((e) => e ? Message.toJSON(e) : undefined);
    } else {
      obj.messages = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<OpenMessageStreamResponse>, I>>(object: I): OpenMessageStreamResponse {
    const message = createBaseOpenMessageStreamResponse();
    message.messages = object.messages?.map((e) => Message.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAckMessagesRequest(): AckMessagesRequest {
  return { rendezvousKey: undefined, messageIds: [] };
}

export const AckMessagesRequest = {
  encode(message: AckMessagesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rendezvousKey !== undefined) {
      RendezvousKey.encode(message.rendezvousKey, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.messageIds) {
      MessageId.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AckMessagesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAckMessagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rendezvousKey = RendezvousKey.decode(reader, reader.uint32());
          break;
        case 2:
          message.messageIds.push(MessageId.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AckMessagesRequest {
    return {
      rendezvousKey: isSet(object.rendezvousKey) ? RendezvousKey.fromJSON(object.rendezvousKey) : undefined,
      messageIds: Array.isArray(object?.messageIds) ? object.messageIds.map((e: any) => MessageId.fromJSON(e)) : [],
    };
  },

  toJSON(message: AckMessagesRequest): unknown {
    const obj: any = {};
    message.rendezvousKey !== undefined &&
      (obj.rendezvousKey = message.rendezvousKey ? RendezvousKey.toJSON(message.rendezvousKey) : undefined);
    if (message.messageIds) {
      obj.messageIds = message.messageIds.map((e) => e ? MessageId.toJSON(e) : undefined);
    } else {
      obj.messageIds = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AckMessagesRequest>, I>>(object: I): AckMessagesRequest {
    const message = createBaseAckMessagesRequest();
    message.rendezvousKey = (object.rendezvousKey !== undefined && object.rendezvousKey !== null)
      ? RendezvousKey.fromPartial(object.rendezvousKey)
      : undefined;
    message.messageIds = object.messageIds?.map((e) => MessageId.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAckMesssagesResponse(): AckMesssagesResponse {
  return { result: 0 };
}

export const AckMesssagesResponse = {
  encode(message: AckMesssagesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AckMesssagesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAckMesssagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.result = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AckMesssagesResponse {
    return { result: isSet(object.result) ? ackMesssagesResponse_ResultFromJSON(object.result) : 0 };
  },

  toJSON(message: AckMesssagesResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = ackMesssagesResponse_ResultToJSON(message.result));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AckMesssagesResponse>, I>>(object: I): AckMesssagesResponse {
    const message = createBaseAckMesssagesResponse();
    message.result = object.result ?? 0;
    return message;
  },
};

function createBaseSendMessageRequest(): SendMessageRequest {
  return { message: undefined, rendezvousKey: undefined, signature: undefined };
}

export const SendMessageRequest = {
  encode(message: SendMessageRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== undefined) {
      Message.encode(message.message, writer.uint32(10).fork()).ldelim();
    }
    if (message.rendezvousKey !== undefined) {
      RendezvousKey.encode(message.rendezvousKey, writer.uint32(18).fork()).ldelim();
    }
    if (message.signature !== undefined) {
      Signature.encode(message.signature, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SendMessageRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.message = Message.decode(reader, reader.uint32());
          break;
        case 2:
          message.rendezvousKey = RendezvousKey.decode(reader, reader.uint32());
          break;
        case 3:
          message.signature = Signature.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SendMessageRequest {
    return {
      message: isSet(object.message) ? Message.fromJSON(object.message) : undefined,
      rendezvousKey: isSet(object.rendezvousKey) ? RendezvousKey.fromJSON(object.rendezvousKey) : undefined,
      signature: isSet(object.signature) ? Signature.fromJSON(object.signature) : undefined,
    };
  },

  toJSON(message: SendMessageRequest): unknown {
    const obj: any = {};
    message.message !== undefined && (obj.message = message.message ? Message.toJSON(message.message) : undefined);
    message.rendezvousKey !== undefined &&
      (obj.rendezvousKey = message.rendezvousKey ? RendezvousKey.toJSON(message.rendezvousKey) : undefined);
    message.signature !== undefined &&
      (obj.signature = message.signature ? Signature.toJSON(message.signature) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SendMessageRequest>, I>>(object: I): SendMessageRequest {
    const message = createBaseSendMessageRequest();
    message.message = (object.message !== undefined && object.message !== null)
      ? Message.fromPartial(object.message)
      : undefined;
    message.rendezvousKey = (object.rendezvousKey !== undefined && object.rendezvousKey !== null)
      ? RendezvousKey.fromPartial(object.rendezvousKey)
      : undefined;
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? Signature.fromPartial(object.signature)
      : undefined;
    return message;
  },
};

function createBaseSendMessageResponse(): SendMessageResponse {
  return { result: 0, messageId: undefined };
}

export const SendMessageResponse = {
  encode(message: SendMessageResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.messageId !== undefined) {
      MessageId.encode(message.messageId, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SendMessageResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.result = reader.int32() as any;
          break;
        case 2:
          message.messageId = MessageId.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SendMessageResponse {
    return {
      result: isSet(object.result) ? sendMessageResponse_ResultFromJSON(object.result) : 0,
      messageId: isSet(object.messageId) ? MessageId.fromJSON(object.messageId) : undefined,
    };
  },

  toJSON(message: SendMessageResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = sendMessageResponse_ResultToJSON(message.result));
    message.messageId !== undefined &&
      (obj.messageId = message.messageId ? MessageId.toJSON(message.messageId) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SendMessageResponse>, I>>(object: I): SendMessageResponse {
    const message = createBaseSendMessageResponse();
    message.result = object.result ?? 0;
    message.messageId = (object.messageId !== undefined && object.messageId !== null)
      ? MessageId.fromPartial(object.messageId)
      : undefined;
    return message;
  },
};

function createBaseMessageId(): MessageId {
  return { value: Buffer.alloc(0) };
}

export const MessageId = {
  encode(message: MessageId, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.value.length !== 0) {
      writer.uint32(10).bytes(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageId {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value = reader.bytes() as Buffer;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MessageId {
    return { value: isSet(object.value) ? Buffer.from(bytesFromBase64(object.value)) : Buffer.alloc(0) };
  },

  toJSON(message: MessageId): unknown {
    const obj: any = {};
    message.value !== undefined &&
      (obj.value = base64FromBytes(message.value !== undefined ? message.value : Buffer.alloc(0)));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MessageId>, I>>(object: I): MessageId {
    const message = createBaseMessageId();
    message.value = object.value ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseRequestForPayment(): RequestForPayment {
  return { requestorAccount: undefined };
}

export const RequestForPayment = {
  encode(message: RequestForPayment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.requestorAccount !== undefined) {
      SolanaAccountId.encode(message.requestorAccount, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RequestForPayment {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestForPayment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.requestorAccount = SolanaAccountId.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RequestForPayment {
    return {
      requestorAccount: isSet(object.requestorAccount) ? SolanaAccountId.fromJSON(object.requestorAccount) : undefined,
    };
  },

  toJSON(message: RequestForPayment): unknown {
    const obj: any = {};
    message.requestorAccount !== undefined &&
      (obj.requestorAccount = message.requestorAccount ? SolanaAccountId.toJSON(message.requestorAccount) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RequestForPayment>, I>>(object: I): RequestForPayment {
    const message = createBaseRequestForPayment();
    message.requestorAccount = (object.requestorAccount !== undefined && object.requestorAccount !== null)
      ? SolanaAccountId.fromPartial(object.requestorAccount)
      : undefined;
    return message;
  },
};

function createBaseMessage(): Message {
  return { id: undefined, sendMessageRequestSignature: undefined, requestForPayment: undefined };
}

export const Message = {
  encode(message: Message, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      MessageId.encode(message.id, writer.uint32(10).fork()).ldelim();
    }
    if (message.sendMessageRequestSignature !== undefined) {
      Signature.encode(message.sendMessageRequestSignature, writer.uint32(26).fork()).ldelim();
    }
    if (message.requestForPayment !== undefined) {
      RequestForPayment.encode(message.requestForPayment, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Message {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = MessageId.decode(reader, reader.uint32());
          break;
        case 3:
          message.sendMessageRequestSignature = Signature.decode(reader, reader.uint32());
          break;
        case 2:
          message.requestForPayment = RequestForPayment.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Message {
    return {
      id: isSet(object.id) ? MessageId.fromJSON(object.id) : undefined,
      sendMessageRequestSignature: isSet(object.sendMessageRequestSignature)
        ? Signature.fromJSON(object.sendMessageRequestSignature)
        : undefined,
      requestForPayment: isSet(object.requestForPayment)
        ? RequestForPayment.fromJSON(object.requestForPayment)
        : undefined,
    };
  },

  toJSON(message: Message): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id ? MessageId.toJSON(message.id) : undefined);
    message.sendMessageRequestSignature !== undefined &&
      (obj.sendMessageRequestSignature = message.sendMessageRequestSignature
        ? Signature.toJSON(message.sendMessageRequestSignature)
        : undefined);
    message.requestForPayment !== undefined && (obj.requestForPayment = message.requestForPayment
      ? RequestForPayment.toJSON(message.requestForPayment)
      : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Message>, I>>(object: I): Message {
    const message = createBaseMessage();
    message.id = (object.id !== undefined && object.id !== null) ? MessageId.fromPartial(object.id) : undefined;
    message.sendMessageRequestSignature =
      (object.sendMessageRequestSignature !== undefined && object.sendMessageRequestSignature !== null)
        ? Signature.fromPartial(object.sendMessageRequestSignature)
        : undefined;
    message.requestForPayment = (object.requestForPayment !== undefined && object.requestForPayment !== null)
      ? RequestForPayment.fromPartial(object.requestForPayment)
      : undefined;
    return message;
  },
};

function createBaseRendezvousKey(): RendezvousKey {
  return { value: Buffer.alloc(0) };
}

export const RendezvousKey = {
  encode(message: RendezvousKey, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.value.length !== 0) {
      writer.uint32(10).bytes(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RendezvousKey {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRendezvousKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value = reader.bytes() as Buffer;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RendezvousKey {
    return { value: isSet(object.value) ? Buffer.from(bytesFromBase64(object.value)) : Buffer.alloc(0) };
  },

  toJSON(message: RendezvousKey): unknown {
    const obj: any = {};
    message.value !== undefined &&
      (obj.value = base64FromBytes(message.value !== undefined ? message.value : Buffer.alloc(0)));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RendezvousKey>, I>>(object: I): RendezvousKey {
    const message = createBaseRendezvousKey();
    message.value = object.value ?? Buffer.alloc(0);
    return message;
  },
};

export type MessagingService = typeof MessagingService;
export const MessagingService = {
  /**
   * OpenMessageStream opens a stream of messages. Messages are routed using the
   * public key of a rendezvous keypair derived by both the sender and the
   * recipient of the messages.
   *
   * Messages are expected to be acked once they have been processed by the client.
   * Ack'd messages will no longer be delivered on future OpenMessageStream calls,
   * and are eligible for deletion from the service. Clients should, however, handle
   * duplicate delivery of messages.
   *
   * For payments, the expected flow is as follows:
   *   1. The payment sender creates a payment scan code
   *      (see: https://github.com/code-wallet/code-api/blob/master/spec/scan.md).
   *   2. The sender calls `OpenMessageStream` on the rendezvous public key, which is derived
   *      by using sha256(scan_payload) as the keypair seed.
   *   3. The payment recipient scans the code and uses `SendMessage` to send their account ID
   *      back to the sender via the rendezvous keypair.
   *   4. The payment sender receives the message, sends the transaction, and closes the stream.
   */
  openMessageStream: {
    path: "/code.messaging.v1.Messaging/OpenMessageStream",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: OpenMessageStreamRequest) => Buffer.from(OpenMessageStreamRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => OpenMessageStreamRequest.decode(value),
    responseSerialize: (value: OpenMessageStreamResponse) =>
      Buffer.from(OpenMessageStreamResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => OpenMessageStreamResponse.decode(value),
  },
  /**
   * AckMessages acks one or more messages that have been successfully delivered to
   * the client.
   */
  ackMessages: {
    path: "/code.messaging.v1.Messaging/AckMessages",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AckMessagesRequest) => Buffer.from(AckMessagesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AckMessagesRequest.decode(value),
    responseSerialize: (value: AckMesssagesResponse) => Buffer.from(AckMesssagesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AckMesssagesResponse.decode(value),
  },
  /** SendMessage sends a message. */
  sendMessage: {
    path: "/code.messaging.v1.Messaging/SendMessage",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendMessageRequest) => Buffer.from(SendMessageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SendMessageRequest.decode(value),
    responseSerialize: (value: SendMessageResponse) => Buffer.from(SendMessageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SendMessageResponse.decode(value),
  },
} as const;

export interface MessagingServer extends UntypedServiceImplementation {
  /**
   * OpenMessageStream opens a stream of messages. Messages are routed using the
   * public key of a rendezvous keypair derived by both the sender and the
   * recipient of the messages.
   *
   * Messages are expected to be acked once they have been processed by the client.
   * Ack'd messages will no longer be delivered on future OpenMessageStream calls,
   * and are eligible for deletion from the service. Clients should, however, handle
   * duplicate delivery of messages.
   *
   * For payments, the expected flow is as follows:
   *   1. The payment sender creates a payment scan code
   *      (see: https://github.com/code-wallet/code-api/blob/master/spec/scan.md).
   *   2. The sender calls `OpenMessageStream` on the rendezvous public key, which is derived
   *      by using sha256(scan_payload) as the keypair seed.
   *   3. The payment recipient scans the code and uses `SendMessage` to send their account ID
   *      back to the sender via the rendezvous keypair.
   *   4. The payment sender receives the message, sends the transaction, and closes the stream.
   */
  openMessageStream: handleServerStreamingCall<OpenMessageStreamRequest, OpenMessageStreamResponse>;
  /**
   * AckMessages acks one or more messages that have been successfully delivered to
   * the client.
   */
  ackMessages: handleUnaryCall<AckMessagesRequest, AckMesssagesResponse>;
  /** SendMessage sends a message. */
  sendMessage: handleUnaryCall<SendMessageRequest, SendMessageResponse>;
}

export interface MessagingClient extends Client {
  /**
   * OpenMessageStream opens a stream of messages. Messages are routed using the
   * public key of a rendezvous keypair derived by both the sender and the
   * recipient of the messages.
   *
   * Messages are expected to be acked once they have been processed by the client.
   * Ack'd messages will no longer be delivered on future OpenMessageStream calls,
   * and are eligible for deletion from the service. Clients should, however, handle
   * duplicate delivery of messages.
   *
   * For payments, the expected flow is as follows:
   *   1. The payment sender creates a payment scan code
   *      (see: https://github.com/code-wallet/code-api/blob/master/spec/scan.md).
   *   2. The sender calls `OpenMessageStream` on the rendezvous public key, which is derived
   *      by using sha256(scan_payload) as the keypair seed.
   *   3. The payment recipient scans the code and uses `SendMessage` to send their account ID
   *      back to the sender via the rendezvous keypair.
   *   4. The payment sender receives the message, sends the transaction, and closes the stream.
   */
  openMessageStream(
    request: OpenMessageStreamRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<OpenMessageStreamResponse>;
  openMessageStream(
    request: OpenMessageStreamRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<OpenMessageStreamResponse>;
  /**
   * AckMessages acks one or more messages that have been successfully delivered to
   * the client.
   */
  ackMessages(
    request: AckMessagesRequest,
    callback: (error: ServiceError | null, response: AckMesssagesResponse) => void,
  ): ClientUnaryCall;
  ackMessages(
    request: AckMessagesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AckMesssagesResponse) => void,
  ): ClientUnaryCall;
  ackMessages(
    request: AckMessagesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AckMesssagesResponse) => void,
  ): ClientUnaryCall;
  /** SendMessage sends a message. */
  sendMessage(
    request: SendMessageRequest,
    callback: (error: ServiceError | null, response: SendMessageResponse) => void,
  ): ClientUnaryCall;
  sendMessage(
    request: SendMessageRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SendMessageResponse) => void,
  ): ClientUnaryCall;
  sendMessage(
    request: SendMessageRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SendMessageResponse) => void,
  ): ClientUnaryCall;
}

export const MessagingClient = makeGenericClientConstructor(
  MessagingService,
  "code.messaging.v1.Messaging",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ChannelOptions>): MessagingClient;
  service: typeof MessagingService;
};

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var globalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

function bytesFromBase64(b64: string): Uint8Array {
  if (globalThis.Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if (globalThis.Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
